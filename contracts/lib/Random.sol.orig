// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

library Random {
    // pseudo random number generator based on block hashes. returns 0 -> max-1
<<<<<<< HEAD
    function prng(
        uint8 numBlocks,
        uint256 max,
        bytes32 seed,
        uint32 epochLength
    ) public view returns (uint256) {
        bytes32 hash = prngHash(numBlocks, seed, epochLength);
        uint256 sum = uint256(hash);
=======
    function prng(uint256 max, bytes32 randHash) public pure returns (uint256) {
        uint256 sum = uint256(randHash);
>>>>>>> 503998d19611ef2ae6d15aa806e14fac5a8f922f
        return (sum % max);
    }

    // pseudo random hash generator based on block hashes.
<<<<<<< HEAD
    function prngHash(
        uint8 numBlocks,
        bytes32 seed,
        uint32 epochLength
    ) public view returns (bytes32) {
        bytes32 sum = blockHashes(numBlocks, epochLength);
        sum = keccak256(abi.encodePacked(sum, seed));
        return (sum);
    }

    function blockHashes(uint8 numBlocks, uint32 epochLength) public view returns (bytes32) {
        bytes32 sum;
        // start from the start of the epoch
        uint256 blockNumberEpochStart = (block.number / (epochLength)) * (epochLength);
        for (uint8 i = 1; i <= numBlocks; i++) {
            sum = keccak256(abi.encodePacked(sum, blockhash(blockNumberEpochStart - i)));
        }
        return (sum);
=======
    function prngHash(bytes32 seed, bytes32 salt) public pure returns (bytes32) {
        bytes32 prngHashVal = keccak256(abi.encodePacked(seed, salt));
        return (prngHashVal);
>>>>>>> 503998d19611ef2ae6d15aa806e14fac5a8f922f
    }

    function encodePacked(uint256[] calldata values) public pure returns (bytes memory returnValue) {
        return abi.encodePacked(values);
    }
}
